> 原本的项目没有提供可以操作目录的脚本, 另外一个同学提供的python脚本因为几个月没有更新也无法正常运转. 因此, 弄一个coffee的脚本copy文件.

###### 20201230
- 开工

```
yarn # 安装依赖包
yarn build # 编译项目
yarn link # 给脚本快捷运行命令
```

###### 20201231

- coffee操作系统命令
- 被master/main坑了, 合并分支.

###### 20210105

```js
//child_process.exec实际调用了下面这个
module.exports.execFile //实际还是调用了spawn
//另一个child_process.spawn()调用了internalBinding
```

- https://medium.com/front-end-weekly/internals-of-node-advance-node-%EF%B8%8F-8612f6a957d7
- https://nodejs.org/dist/latest-v15.x/docs/api/child_process.html

```js
const { spawn } = require('child_process');
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) => {
  console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) => {
  console.error(`stderr: ${data}`);
});

ls.on('close', (code) => {
  console.log(`child process exited with code ${code}`);
});
```

###### 20210107

- 继续操作命令行
- 有四个函数对spawn进行了包装.
  - child_process.spawn（），
  - child_process.fork（）执行并且建立一个IPC channel, 可以传消息
  - child_process.exec（）包装spawn, 并且使用新的shell
  - child_process.execFile（）包装spawn, 但是不使用新的shell
- 这四个函数都返回childprocess实例
  - 这个对象实现了eventEmitter
  - 因此可以注册listener
  - exec和execfile还可以传入一个回调函数, 在完成命令后回调
- 命令行调用部分形成blog.

###### 20210108

- 包装我的常用函数

```sh
diskutil list
sudo fsck_apfs /dev/disk4
sudo ./bin/apfs-inspect /dev/disk4
sudo ./bin/apfs-list /dev/disk3s2 0 / 

sudo ../bin/apfs-recover /dev/disk4 0 "/地图/元素周期表-timg-3.jpeg" > "/Volumes/wd4black/back/地图/元素周期表-timg-3.jpeg"
mkdir /Volumes/wd4black/back/地图 # 新建目录, 如果目录不存在会报错

#不论是否有引号都可以正常执行.
bd --back disk4 "/地图/元素周期表-timg-3.jpeg" "/Volumes/wd4black/back/aaa.jpeg"
bd --back disk4 /地图/元素周期表-timg-3.jpeg /Volumes/wd4black/back/bbb.jpeg
```

- iscmd需要抽取出来
- 单独备份初步完成, 下一步是根据目录情况进行备份.